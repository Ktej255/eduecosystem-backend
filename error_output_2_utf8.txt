============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-9.0.1, pluggy-1.6.0 -- C:\Users\Sarit\AppData\Local\Programs\Python\Python313\python.exe
cachedir: .pytest_cache
rootdir: D:\Graphology\Master Software\Eduecosystem\backend
configfile: pytest.ini
plugins: anyio-4.11.0, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/api/test_discussions.py::test_create_discussion_thread ERROR       [100%]

=================================== ERRORS ====================================
_______________ ERROR at setup of test_create_discussion_thread _______________

self = <Mapper at 0x1ebef005810; Course>, key = 'learning_groups'
_configure_mappers = False

    def get_property(
        self, key: str, _configure_mappers: bool = False
    ) -> MapperProperty[Any]:
        """return a MapperProperty associated with the given key."""
    
        if _configure_mappers:
            self._check_configure()
    
        try:
>           return self._props[key]
                   ^^^^^^^^^^^^^^^^
E           KeyError: 'learning_groups'

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2522: KeyError

The above exception was the direct cause of the following exception:

db = <sqlalchemy.orm.session.Session object at 0x000001EBB2CBBE00>

    @pytest.fixture
    def instructor_user(db: Session) -> User:
        """Create an instructor user"""
        from app.core.security import get_password_hash
>       user = User(
            email="instructor_disc@test.com",
            username="instructor_disc",
            hashed_password=get_password_hash("password"),
            full_name="Test Instructor",
            role="instructor",
            is_superuser=True,
            is_active=True
        )

tests\api\test_discussions.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EBB31523C0>
kwargs = {'email': 'instructor_disc@test.com', 'full_name': 'Test Instructor', 'hashed_password': '$2b$12$vcyPkNs0jWzMQrppomzjF.ZrV59hITZcmKsVs6ZaDmJFVWaSqQrMO', 'is_active': True, ...}
new_state = <sqlalchemy.orm.state.InstanceState object at 0x000001EBB2ED8470>

>   ???

<string>:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

mixed = (<sqlalchemy.orm.state.InstanceState object at 0x000001EBB2ED8470>, <app.models.user.User object at 0x000001EBB31523C0>)
kwargs = {'email': 'instructor_disc@test.com', 'full_name': 'Test Instructor', 'hashed_password': '$2b$12$vcyPkNs0jWzMQrppomzjF.ZrV59hITZcmKsVs6ZaDmJFVWaSqQrMO', 'is_active': True, ...}
self = <sqlalchemy.orm.state.InstanceState object at 0x000001EBB2ED8470>
instance = <app.models.user.User object at 0x000001EBB31523C0>, args = ()
manager = <ClassManager of <class 'app.models.user.User'> at 1ebeec09c70>

    def _initialize_instance(*mixed: Any, **kwargs: Any) -> None:
        self, instance, args = mixed[0], mixed[1], mixed[2:]  # noqa
        manager = self.manager
    
>       manager.dispatch.init(self, args, kwargs)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\state.py:566: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.event.attr._ListenerCollection object at 0x000001EBEED8D5D0>
args = (<sqlalchemy.orm.state.InstanceState object at 0x000001EBB2ED8470>, (), {'email': 'instructor_disc@test.com', 'full_na...nstructor', 'hashed_password': '$2b$12$vcyPkNs0jWzMQrppomzjF.ZrV59hITZcmKsVs6ZaDmJFVWaSqQrMO', 'is_active': True, ...})
kw = {}, fn = <function _event_on_init at 0x000001EBEE3AFBA0>

    def __call__(self, *args: Any, **kw: Any) -> None:
        """Execute this event."""
    
        for fn in self.parent_listeners:
            fn(*args, **kw)
        for fn in self.listeners:
>           fn(*args, **kw)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\event\attr.py:515: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

state = <sqlalchemy.orm.state.InstanceState object at 0x000001EBB2ED8470>
args = ()
kwargs = {'email': 'instructor_disc@test.com', 'full_name': 'Test Instructor', 'hashed_password': '$2b$12$vcyPkNs0jWzMQrppomzjF.ZrV59hITZcmKsVs6ZaDmJFVWaSqQrMO', 'is_active': True, ...}

    def _event_on_init(state, args, kwargs):
        """Run init_instance hooks.
    
        This also includes mapper compilation, normally not needed
        here but helps with some piecemeal configuration
        scenarios (such as in the ORM tutorial).
    
        """
    
        instrumenting_mapper = state.manager.mapper
        if instrumenting_mapper:
>           instrumenting_mapper._check_configure()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:4410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x1ebeed75090; User>

    @util.langhelpers.tag_method_for_warnings(
        "This warning originated from the `configure_mappers()` process, "
        "which was invoked automatically in response to a user-initiated "
        "operation.",
        sa_exc.SAWarning,
    )
    def _check_configure(self) -> None:
        if self.registry._new_mappers:
>           _configure_registries({self.registry}, cascade=True)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

registries = set(), cascade = True

    def _configure_registries(
        registries: Set[_RegistryType], cascade: bool
    ) -> None:
        for reg in registries:
            if reg._new_mappers:
                break
        else:
            return
    
        with _CONFIGURE_MUTEX:
            global _already_compiling
            if _already_compiling:
                return
            _already_compiling = True
            try:
                # double-check inside mutex
                for reg in registries:
                    if reg._new_mappers:
                        break
                else:
                    return
    
                Mapper.dispatch._for_class(Mapper).before_configured()  # type: ignore # noqa: E501
                # initialize properties on all mappers
                # note that _mapper_registry is unordered, which
                # may randomly conceal/reveal issues related to
                # the order of mapper compilation
    
>               _do_configure_registries(registries, cascade)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:4218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

registries = set(), cascade = True

    @util.preload_module("sqlalchemy.orm.decl_api")
    def _do_configure_registries(
        registries: Set[_RegistryType], cascade: bool
    ) -> None:
        registry = util.preloaded.orm_decl_api.registry
    
        orig = set(registries)
    
        for reg in registry._recurse_with_dependencies(registries):
            has_skip = False
    
            for mapper in reg._mappers_to_configure():
                run_configure = None
    
                for fn in mapper.dispatch.before_mapper_configured:
                    run_configure = fn(mapper, mapper.class_)
                    if run_configure is EXT_SKIP:
                        has_skip = True
                        break
                if run_configure is EXT_SKIP:
                    continue
    
                if getattr(mapper, "_configure_failed", False):
                    e = sa_exc.InvalidRequestError(
                        "One or more mappers failed to initialize - "
                        "can't proceed with initialization of other "
                        "mappers. Triggering mapper: '%s'. "
                        "Original exception was: %s"
                        % (mapper, mapper._configure_failed)
                    )
                    e._configure_failed = mapper._configure_failed  # type: ignore
                    raise e
    
                if not mapper.configured:
                    try:
>                       mapper._post_configure_properties()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:4259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x1ebef1c4410; LearningGroup>

    def _post_configure_properties(self) -> None:
        """Call the ``init()`` method on all ``MapperProperties``
        attached to this mapper.
    
        This is a deferred configuration step which is intended
        to execute once all mappers have been constructed.
    
        """
    
        self._log("_post_configure_properties() started")
        l = [(key, prop) for key, prop in self._props.items()]
        for key, prop in l:
            self._log("initialize prop %s", key)
    
            if prop.parent is self and not prop._configure_started:
>               prop.init()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x1ebef1ddf90; course>

    def init(self) -> None:
        """Called after all mappers are created to assemble
        relationships between mappers and perform other post-mapper-creation
        initialization steps.
    
    
        """
        self._configure_started = True
>       self.do_init()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\interfaces.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x1ebef1ddf90; course>

    def do_init(self) -> None:
        self._check_conflicts()
        self._process_dependent_arguments()
        self._setup_entity()
        self._setup_registry_dependencies()
        self._setup_join_conditions()
        self._check_cascade_settings(self._cascade)
        self._post_init()
>       self._generate_backref()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:1660: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x1ebef1ddf90; course>

    def _generate_backref(self) -> None:
        """Interpret the 'backref' instruction to create a
        :func:`_orm.relationship` complementary to this one."""
    
        if self.parent.non_primary:
            return
        if self.backref is not None and not self.back_populates:
            kwargs: Dict[str, Any]
            if isinstance(self.backref, str):
                backref_key, kwargs = self.backref, {}
            else:
                backref_key, kwargs = self.backref
            mapper = self.mapper.primary_mapper()
    
            if not mapper.concrete:
                check = set(mapper.iterate_to_root()).union(
                    mapper.self_and_descendants
                )
                for m in check:
                    if m.has_property(backref_key) and not m.concrete:
                        raise sa_exc.ArgumentError(
                            "Error creating backref "
                            "'%s' on relationship '%s': property of that "
                            "name exists on mapper '%s'"
                            % (backref_key, self, m)
                        )
    
            # determine primaryjoin/secondaryjoin for the
            # backref.  Use the one we had, so that
            # a custom join doesn't have to be specified in
            # both directions.
            if self.secondary is not None:
                # for many to many, just switch primaryjoin/
                # secondaryjoin.   use the annotated
                # pj/sj on the _join_condition.
                pj = kwargs.pop(
                    "primaryjoin",
                    self._join_condition.secondaryjoin_minus_local,
                )
                sj = kwargs.pop(
                    "secondaryjoin",
                    self._join_condition.primaryjoin_minus_local,
                )
            else:
                pj = kwargs.pop(
                    "primaryjoin",
                    self._join_condition.primaryjoin_reverse_remote,
                )
                sj = kwargs.pop("secondaryjoin", None)
                if sj:
                    raise sa_exc.InvalidRequestError(
                        "Can't assign 'secondaryjoin' on a backref "
                        "against a non-secondary relationship."
                    )
    
            foreign_keys = kwargs.pop(
                "foreign_keys", self._user_defined_foreign_keys
            )
            parent = self.parent.primary_mapper()
            kwargs.setdefault("viewonly", self.viewonly)
            kwargs.setdefault("post_update", self.post_update)
            kwargs.setdefault("passive_updates", self.passive_updates)
            kwargs.setdefault("sync_backref", self.sync_backref)
            self.back_populates = backref_key
            relationship = RelationshipProperty(
                parent,
                self.secondary,
                primaryjoin=pj,
                secondaryjoin=sj,
                foreign_keys=foreign_keys,
                back_populates=self.key,
                **kwargs,
            )
            mapper._configure_property(
                backref_key, relationship, warn_for_existing=True
            )
    
        if self.back_populates:
>           self._add_reverse_property(self.back_populates)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:2144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x1ebef1ddf90; course>, key = 'learning_groups'

    def _add_reverse_property(self, key: str) -> None:
>       other = self.mapper.get_property(key, _configure_mappers=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:1591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x1ebef005810; Course>, key = 'learning_groups'
_configure_mappers = False

    def get_property(
        self, key: str, _configure_mappers: bool = False
    ) -> MapperProperty[Any]:
        """return a MapperProperty associated with the given key."""
    
        if _configure_mappers:
            self._check_configure()
    
        try:
            return self._props[key]
        except KeyError as err:
>           raise sa_exc.InvalidRequestError(
                f"Mapper '{self}' has no property '{key}'.  If this property "
                "was indicated from other mappers or configure events, ensure "
                "registry.configure() has been called."
            ) from err
E           sqlalchemy.exc.InvalidRequestError: Mapper 'Mapper[Course(courses)]' has no property 'learning_groups'.  If this property was indicated from other mappers or configure events, ensure registry.configure() has been called.

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2524: InvalidRequestError
----------------------------- Captured log setup ------------------------------
WARNING  app.core.redis_cache:redis_cache.py:37 Redis connection failed: Error 10061 connecting to localhost:6379. No connection could be made because the target machine actively refused it.. Caching disabled.
WARNING  main:main.py:38 Redis cache not available - running without cache
============================== warnings summary ===============================
app\schemas\coupon.py:28
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:28: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator('discount_type')

app\schemas\coupon.py:34
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:34: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator('discount_value')

app\schemas\coupon.py:54
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:54: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class Coupon(CouponBase):

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\detection.py:81
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\detection.py:81: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    torch.quantization.quantize_dynamic(net, dtype=torch.qint8, inplace=True)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\torch\ao\quantization\quantize.py:566
C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\torch\ao\quantization\quantize.py:566
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\torch\ao\quantization\quantize.py:566: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    convert(model, mapping, inplace=True)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\recognition.py:177
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\recognition.py:177: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    torch.quantization.quantize_dynamic(model, dtype=torch.qint8, inplace=True)

app\api\api_v1\endpoints\earnings.py:45
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\earnings.py:45: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class Transaction(BaseModel):

tests/api/test_discussions.py::test_create_discussion_thread
  D:\Graphology\Master Software\Eduecosystem\backend\tests\conftest.py:45: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: lessons, modules, quizzes; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    Base.metadata.drop_all(bind=engine)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
ERROR tests/api/test_discussions.py::test_create_discussion_thread - sqlalche...
======================== 9 warnings, 1 error in 6.57s =========================
