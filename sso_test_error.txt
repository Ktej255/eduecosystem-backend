============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-9.0.1, pluggy-1.6.0 -- C:\Users\Sarit\AppData\Local\Programs\Python\Python313\python.exe
cachedir: .pytest_cache
rootdir: D:\Graphology\Master Software\Eduecosystem\backend
configfile: pytest.ini
plugins: anyio-4.11.0, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow FAILED      [100%]

================================== FAILURES ===================================
_____________________________ test_sso_full_flow ______________________________

self = <Mapper at 0x20c0abb34d0; Submission>, key = 'plagiarism_checks'
_configure_mappers = False

    def get_property(
        self, key: str, _configure_mappers: bool = False
    ) -> MapperProperty[Any]:
        """return a MapperProperty associated with the given key."""
    
        if _configure_mappers:
            self._check_configure()
    
        try:
>           return self._props[key]
                   ^^^^^^^^^^^^^^^^
E           KeyError: 'plagiarism_checks'

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2522: KeyError

The above exception was the direct cause of the following exception:

client = <starlette.testclient.TestClient object at 0x0000020C0CF70590>
db = <sqlalchemy.orm.session.Session object at 0x0000020C0CF702F0>

    def test_sso_full_flow(client: TestClient, db: Session):
        """
        Test the full lifecycle of Enterprise SSO:
        1. Admin creates Organization
        2. Admin configures SSO (OAuth)
        3. User initiates Login
        4. User completes Callback
        """
        print("Starting test_sso_full_flow")
    
        # 1. Admin Login & Create Organization
>       superuser_headers = get_superuser_headers(client, db)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\api\api_v1\test_sso_integration.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x0000020C0CF70590>
db = <sqlalchemy.orm.session.Session object at 0x0000020C0CF702F0>

    def get_superuser_headers(client: TestClient, db: Session) -> dict:
        print("Getting superuser headers...")
        email = settings.FIRST_SUPERUSER
        password = settings.FIRST_SUPERUSER_PASSWORD
>       user = crud_user.get_by_email(db, email=email)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\api\api_v1\test_sso_integration.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

db = <sqlalchemy.orm.session.Session object at 0x0000020C0CF702F0>
email = 'admin@example.com'

    def get_by_email(db: Session, email: str) -> Optional[User]:
>       return db.query(User).filter(User.email == email).first()
               ^^^^^^^^^^^^^^

app\crud\user.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.orm.session.Session object at 0x0000020C0CF702F0>
entities = (<class 'app.models.user.User'>,), kwargs = {}

    def query(
        self, *entities: _ColumnsClauseArgument[Any], **kwargs: Any
    ) -> Query[Any]:
        """Return a new :class:`_query.Query` object corresponding to this
        :class:`_orm.Session`.
    
        Note that the :class:`_query.Query` object is legacy as of
        SQLAlchemy 2.0; the :func:`_sql.select` construct is now used
        to construct ORM queries.
    
        .. seealso::
    
            :ref:`unified_tutorial`
    
            :ref:`queryguide_toplevel`
    
            :ref:`query_api_toplevel` - legacy API doc
    
        """
    
>       return self._query_cls(entities, self, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\session.py:2941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.orm.query.Query object at 0x0000020C4FBD4440>
entities = (<class 'app.models.user.User'>,)
session = <sqlalchemy.orm.session.Session object at 0x0000020C0CF702F0>

    def __init__(
        self,
        entities: Union[
            _ColumnsClauseArgument[Any], Sequence[_ColumnsClauseArgument[Any]]
        ],
        session: Optional[Session] = None,
    ):
        """Construct a :class:`_query.Query` directly.
    
        E.g.::
    
            q = Query([User, Address], session=some_session)
    
        The above is equivalent to::
    
            q = some_session.query(User, Address)
    
        :param entities: a sequence of entities and/or SQL expressions.
    
        :param session: a :class:`.Session` with which the
         :class:`_query.Query`
         will be associated.   Optional; a :class:`_query.Query`
         can be associated
         with a :class:`.Session` generatively via the
         :meth:`_query.Query.with_session` method as well.
    
        .. seealso::
    
            :meth:`.Session.query`
    
            :meth:`_query.Query.with_session`
    
        """
    
        # session is usually present.  There's one case in subqueryloader
        # where it stores a Query without a Session and also there are tests
        # for the query(Entity).with_session(session) API which is likely in
        # some old recipes, however these are legacy as select() can now be
        # used.
        self.session = session  # type: ignore
>       self._set_entities(entities)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\query.py:276: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.orm.query.Query object at 0x0000020C4FBD4440>
entities = (<class 'app.models.user.User'>,)

    def _set_entities(
        self,
        entities: Union[
            _ColumnsClauseArgument[Any], Iterable[_ColumnsClauseArgument[Any]]
        ],
    ) -> None:
        self._raw_columns = [
>           coercions.expect(
                roles.ColumnsClauseRole,
                ent,
                apply_propagate_attrs=self,
                post_inspect=True,
            )
            for ent in util.to_list(entities)
        ]

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\query.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

role = <class 'sqlalchemy.sql.roles.ColumnsClauseRole'>
element = <class 'app.models.user.User'>
apply_propagate_attrs = <sqlalchemy.orm.query.Query object at 0x0000020C4FBD4440>
argname = None, post_inspect = True, disable_inspection = False, kw = {}
impl = <sqlalchemy.sql.coercions.ColumnsClauseImpl object at 0x0000020C087C5D00>
original_element = <class 'app.models.user.User'>, resolved = None

    def expect(
        role: Type[_SR],
        element: Any,
        *,
        apply_propagate_attrs: Optional[ClauseElement] = None,
        argname: Optional[str] = None,
        post_inspect: bool = False,
        disable_inspection: bool = False,
        **kw: Any,
    ) -> Any:
        if (
            role.allows_lambda
            # note callable() will not invoke a __getattr__() method, whereas
            # hasattr(obj, "__call__") will. by keeping the callable() check here
            # we prevent most needless calls to hasattr()  and therefore
            # __getattr__(), which is present on ColumnElement.
            and callable(element)
            and hasattr(element, "__code__")
        ):
            return lambdas.LambdaElement(
                element,
                role,
                lambdas.LambdaOptions(**kw),
                apply_propagate_attrs=apply_propagate_attrs,
            )
    
        # major case is that we are given a ClauseElement already, skip more
        # elaborate logic up front if possible
        impl = _impl_lookup[role]
    
        original_element = element
    
        if not isinstance(
            element,
            (
                elements.CompilerElement,
                schema.SchemaItem,
                schema.FetchedValue,
                lambdas.PyWrapper,
            ),
        ):
            resolved = None
    
            if impl._resolve_literal_only:
                resolved = impl._literal_coercion(element, **kw)
            else:
                original_element = element
    
                is_clause_element = False
    
                # this is a special performance optimization for ORM
                # joins used by JoinTargetImpl that we don't go through the
                # work of creating __clause_element__() when we only need the
                # original QueryableAttribute, as the former will do clause
                # adaption and all that which is just thrown away here.
                if (
                    impl._skip_clauseelement_for_target_match
                    and isinstance(element, role)
                    and hasattr(element, "__clause_element__")
                ):
                    is_clause_element = True
                else:
                    while hasattr(element, "__clause_element__"):
                        is_clause_element = True
    
                        if not getattr(element, "is_clause_element", False):
                            element = element.__clause_element__()
                        else:
                            break
    
                if not is_clause_element:
                    if impl._use_inspection and not disable_inspection:
                        insp = inspection.inspect(element, raiseerr=False)
                        if insp is not None:
                            if post_inspect:
>                               insp._post_inspect

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\sql\coercions.py:388: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.util.langhelpers.HasMemoized.memoized_attribute object at 0x0000020C08DFF590>
obj = <Mapper at 0x20c0aaebc50; User>
cls = <class 'sqlalchemy.orm.mapper.Mapper'>

    def __get__(self, obj, cls):
        if obj is None:
            return self
>       obj.__dict__[self.__name__] = result = self.fget(obj)
                                               ^^^^^^^^^^^^^^

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\util\langhelpers.py:1338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x20c0aaebc50; User>

    @HasMemoized.memoized_attribute
    def _post_inspect(self):
        """This hook is invoked by attribute inspection.
    
        E.g. when Query calls:
    
            coercions.expect(roles.ColumnsClauseRole, ent, keep_inspect=True)
    
        This allows the inspection process run a configure mappers hook.
    
        """
>       self._check_configure()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2724: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x20c0aaebc50; User>

    @util.langhelpers.tag_method_for_warnings(
        "This warning originated from the `configure_mappers()` process, "
        "which was invoked automatically in response to a user-initiated "
        "operation.",
        sa_exc.SAWarning,
    )
    def _check_configure(self) -> None:
        if self.registry._new_mappers:
>           _configure_registries({self.registry}, cascade=True)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

registries = set(), cascade = True

    def _configure_registries(
        registries: Set[_RegistryType], cascade: bool
    ) -> None:
        for reg in registries:
            if reg._new_mappers:
                break
        else:
            return
    
        with _CONFIGURE_MUTEX:
            global _already_compiling
            if _already_compiling:
                return
            _already_compiling = True
            try:
                # double-check inside mutex
                for reg in registries:
                    if reg._new_mappers:
                        break
                else:
                    return
    
                Mapper.dispatch._for_class(Mapper).before_configured()  # type: ignore # noqa: E501
                # initialize properties on all mappers
                # note that _mapper_registry is unordered, which
                # may randomly conceal/reveal issues related to
                # the order of mapper compilation
    
>               _do_configure_registries(registries, cascade)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:4218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

registries = set(), cascade = True

    @util.preload_module("sqlalchemy.orm.decl_api")
    def _do_configure_registries(
        registries: Set[_RegistryType], cascade: bool
    ) -> None:
        registry = util.preloaded.orm_decl_api.registry
    
        orig = set(registries)
    
        for reg in registry._recurse_with_dependencies(registries):
            has_skip = False
    
            for mapper in reg._mappers_to_configure():
                run_configure = None
    
                for fn in mapper.dispatch.before_mapper_configured:
                    run_configure = fn(mapper, mapper.class_)
                    if run_configure is EXT_SKIP:
                        has_skip = True
                        break
                if run_configure is EXT_SKIP:
                    continue
    
                if getattr(mapper, "_configure_failed", False):
                    e = sa_exc.InvalidRequestError(
                        "One or more mappers failed to initialize - "
                        "can't proceed with initialization of other "
                        "mappers. Triggering mapper: '%s'. "
                        "Original exception was: %s"
                        % (mapper, mapper._configure_failed)
                    )
                    e._configure_failed = mapper._configure_failed  # type: ignore
                    raise e
    
                if not mapper.configured:
                    try:
>                       mapper._post_configure_properties()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:4259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x20c0b24b250; PlagiarismCheck>

    def _post_configure_properties(self) -> None:
        """Call the ``init()`` method on all ``MapperProperties``
        attached to this mapper.
    
        This is a deferred configuration step which is intended
        to execute once all mappers have been constructed.
    
        """
    
        self._log("_post_configure_properties() started")
        l = [(key, prop) for key, prop in self._props.items()]
        for key, prop in l:
            self._log("initialize prop %s", key)
    
            if prop.parent is self and not prop._configure_started:
>               prop.init()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x20c0b39f070; submission>

    def init(self) -> None:
        """Called after all mappers are created to assemble
        relationships between mappers and perform other post-mapper-creation
        initialization steps.
    
    
        """
        self._configure_started = True
>       self.do_init()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\interfaces.py:595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x20c0b39f070; submission>

    def do_init(self) -> None:
        self._check_conflicts()
        self._process_dependent_arguments()
        self._setup_entity()
        self._setup_registry_dependencies()
        self._setup_join_conditions()
        self._check_cascade_settings(self._cascade)
        self._post_init()
>       self._generate_backref()

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:1660: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x20c0b39f070; submission>

    def _generate_backref(self) -> None:
        """Interpret the 'backref' instruction to create a
        :func:`_orm.relationship` complementary to this one."""
    
        if self.parent.non_primary:
            return
        if self.backref is not None and not self.back_populates:
            kwargs: Dict[str, Any]
            if isinstance(self.backref, str):
                backref_key, kwargs = self.backref, {}
            else:
                backref_key, kwargs = self.backref
            mapper = self.mapper.primary_mapper()
    
            if not mapper.concrete:
                check = set(mapper.iterate_to_root()).union(
                    mapper.self_and_descendants
                )
                for m in check:
                    if m.has_property(backref_key) and not m.concrete:
                        raise sa_exc.ArgumentError(
                            "Error creating backref "
                            "'%s' on relationship '%s': property of that "
                            "name exists on mapper '%s'"
                            % (backref_key, self, m)
                        )
    
            # determine primaryjoin/secondaryjoin for the
            # backref.  Use the one we had, so that
            # a custom join doesn't have to be specified in
            # both directions.
            if self.secondary is not None:
                # for many to many, just switch primaryjoin/
                # secondaryjoin.   use the annotated
                # pj/sj on the _join_condition.
                pj = kwargs.pop(
                    "primaryjoin",
                    self._join_condition.secondaryjoin_minus_local,
                )
                sj = kwargs.pop(
                    "secondaryjoin",
                    self._join_condition.primaryjoin_minus_local,
                )
            else:
                pj = kwargs.pop(
                    "primaryjoin",
                    self._join_condition.primaryjoin_reverse_remote,
                )
                sj = kwargs.pop("secondaryjoin", None)
                if sj:
                    raise sa_exc.InvalidRequestError(
                        "Can't assign 'secondaryjoin' on a backref "
                        "against a non-secondary relationship."
                    )
    
            foreign_keys = kwargs.pop(
                "foreign_keys", self._user_defined_foreign_keys
            )
            parent = self.parent.primary_mapper()
            kwargs.setdefault("viewonly", self.viewonly)
            kwargs.setdefault("post_update", self.post_update)
            kwargs.setdefault("passive_updates", self.passive_updates)
            kwargs.setdefault("sync_backref", self.sync_backref)
            self.back_populates = backref_key
            relationship = RelationshipProperty(
                parent,
                self.secondary,
                primaryjoin=pj,
                secondaryjoin=sj,
                foreign_keys=foreign_keys,
                back_populates=self.key,
                **kwargs,
            )
            mapper._configure_property(
                backref_key, relationship, warn_for_existing=True
            )
    
        if self.back_populates:
>           self._add_reverse_property(self.back_populates)

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:2144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <_RelationshipDeclared at 0x20c0b39f070; submission>
key = 'plagiarism_checks'

    def _add_reverse_property(self, key: str) -> None:
>       other = self.mapper.get_property(key, _configure_mappers=False)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\relationships.py:1591: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Mapper at 0x20c0abb34d0; Submission>, key = 'plagiarism_checks'
_configure_mappers = False

    def get_property(
        self, key: str, _configure_mappers: bool = False
    ) -> MapperProperty[Any]:
        """return a MapperProperty associated with the given key."""
    
        if _configure_mappers:
            self._check_configure()
    
        try:
            return self._props[key]
        except KeyError as err:
>           raise sa_exc.InvalidRequestError(
                f"Mapper '{self}' has no property '{key}'.  If this property "
                "was indicated from other mappers or configure events, ensure "
                "registry.configure() has been called."
            ) from err
E           sqlalchemy.exc.InvalidRequestError: Mapper 'Mapper[Submission(submissions)]' has no property 'plagiarism_checks'.  If this property was indicated from other mappers or configure events, ensure registry.configure() has been called.

C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\sqlalchemy\orm\mapper.py:2524: InvalidRequestError
---------------------------- Captured stdout setup ----------------------------
WARNING: GEMINI_API_KEY not found in environment variables
WARNING: TWO_FACTOR_ENCRYPTION_KEY not set. Using temporary key.
---------------------------- Captured stderr setup ----------------------------
Server initialized for asgi.
----------------------------- Captured log setup ------------------------------
WARNING  app.core.storage:storage.py:24 boto3 not installed. S3 storage unavailable.
WARNING  app.core.virus_scanner:virus_scanner.py:17 pyclamd not installed. Virus scanning disabled.
WARNING  easyocr.easyocr:easyocr.py:71 Using CPU. Note: This module is much faster with a GPU.
INFO     engineio.server:base_server.py:112 Server initialized for asgi.
WARNING  main:main.py:38 Redis cache not available - running without cache
WARNING  main:main.py:82 Redis Pub/Sub not available - WebSocket scaling disabled
---------------------------- Captured stdout call -----------------------------
Starting test_sso_full_flow
Getting superuser headers...
============================== warnings summary ===============================
app\schemas\coupon.py:28
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:28: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator('discount_type')

app\schemas\coupon.py:34
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:34: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator('discount_value')

app\schemas\coupon.py:54
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\coupon.py:54: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class Coupon(CouponBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\detection.py:81: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    torch.quantization.quantize_dynamic(net, dtype=torch.qint8, inplace=True)

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\torch\ao\quantization\quantize.py:566: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    convert(model, mapping, inplace=True)

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\easyocr\recognition.py:177: DeprecationWarning: torch.ao.quantization is deprecated and will be removed in 2.10. 
  For migrations of users: 
  1. Eager mode quantization (torch.ao.quantization.quantize, torch.ao.quantization.quantize_dynamic), please migrate to use torchao eager mode quantize_ API instead 
  2. FX graph mode quantization (torch.ao.quantization.quantize_fx.prepare_fx,torch.ao.quantization.quantize_fx.convert_fx, please migrate to use torchao pt2e quantization API instead (prepare_pt2e, convert_pt2e) 
  3. pt2e quantization has been migrated to torchao (https://github.com/pytorch/ao/tree/main/torchao/quantization/pt2e) 
  see https://github.com/pytorch/ao/issues/2259 for more details
    torch.quantization.quantize_dynamic(model, dtype=torch.qint8, inplace=True)

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\analytics.py:27: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class InstructorAnalyticsResponse(InstructorAnalyticsBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\analytics.py:95: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class StudentAnalyticsResponse(StudentAnalyticsBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\analytics.py:157: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class PlatformAnalyticsResponse(PlatformAnalyticsBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\analytics.py:239: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class EventResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\marketplace.py:42: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class PayoutResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  C:\Users\Sarit\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic\_internal\_config.py:383: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\marketplace.py:78: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class BundleResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\marketplace.py:105: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class PlanResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\marketplace.py:119: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class SubscriptionResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\translation.py:36: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class Language(LanguageBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\translation.py:65: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class Translation(TranslationBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\translation.py:110: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ContentTranslation(ContentTranslationBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\translation.py:162: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class UserLanguagePreference(UserLanguagePreferenceBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\ai_tools.py:29: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class EssayGradeResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\ai_tools.py:61: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class DifficultyAnalysisResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\ai_tools.py:78: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class PlagiarismCheckResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\sso.py:45: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class OrganizationResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\sso.py:78: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class SSOConfigResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\sso.py:98: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class SSOSessionResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\sso.py:109: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class SSOEventResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\revenue_analytics.py:56: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    comparison_type: str = Query("mom", regex="^(mom|yoy|custom)$"),

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\payment_method.py:33: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class PaymentMethodResponse(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\tax.py:55: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TaxRateResponse(TaxRateBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\tax.py:89: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TaxCalculationDetail(BaseModel):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\schemas\tax.py:136: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TaxExemptionResponse(TaxExemptionBase):

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\exports.py:25: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    format: str = Query("csv", regex="^(csv|pdf|json)$"),

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\exports.py:75: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    format: str = Query("json", regex="^(json|pdf)$")

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\exports.py:122: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    format: str = Query("json", regex="^(json|pdf)$")

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\app\api\api_v1\endpoints\exports.py:166: DeprecationWarning: `regex` has been deprecated, please use `pattern` instead
    format: str = Query("csv", regex="^(csv|pdf)$")

tests/api/api_v1/test_sso_integration.py::test_sso_full_flow
  D:\Graphology\Master Software\Eduecosystem\backend\tests\conftest.py:59: SAWarning: Can't sort tables for DROP; an unresolvable foreign key dependency exists between tables: lessons, modules, quizzes; and backend does not support ALTER.  To restore at least a partial sort, apply use_alter=True to ForeignKey and ForeignKeyConstraint objects involved in the cycle to mark these as known cycles that will be ignored.
    Base.metadata.drop_all(bind=engine)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/api/api_v1/test_sso_integration.py::test_sso_full_flow - sqlalch...
======================= 1 failed, 39 warnings in 13.94s =======================
